================================================================================
                    BIBLIOTECA SECRETS DO PYTHON
                           NÍVEL INICIANTE
================================================================================



================================================================================
1. INTRODUÇÃO À BIBLIOTECA SECRETS
================================================================================

1.1 O QUE É A BIBLIOTECA SECRETS?
--------------------------------------------------------------------------------
A biblioteca secrets foi introduzida no Python 3.6 para gerar números 
aleatórios criptograficamente seguros. Ela é projetada especificamente para 
gerenciar dados sensíveis como senhas, tokens de autenticação, chaves de 
segurança e outros segredos.

Diferença fundamental:
- random: aleatoriedade pseudoaleatória (não segura)
- secrets: aleatoriedade criptograficamente segura

Exemplo de uso inadequado vs adequado:
# ❌ NÃO USE random para segurança
import random
senha = random.randint(1000, 9999)  # INSEGURO!

# ✅ USE secrets para segurança
import secrets
token = secrets.token_hex(16)  # SEGURO!

1.2 POR QUE USAR SECRETS?
--------------------------------------------------------------------------------
Benefícios da biblioteca secrets:
- Gera números verdadeiramente aleatórios e imprevisíveis
- Adequada para aplicações de segurança e criptografia
- Resistente a ataques de previsão
- Usa fontes de entropia do sistema operacional
- Simples e fácil de usar

Casos de uso apropriados:
✅ Geração de senhas
✅ Tokens de autenticação
✅ Tokens de redefinição de senha
✅ Chaves de API
✅ Tokens de sessão
✅ Nonces criptográficos
✅ Salts para hashing de senhas

Casos onde random é suficiente:
⚠️  Jogos e simulações
⚠️  Amostragem estatística
⚠️  Shuffling de listas não-sensíveis
⚠️  Seleção aleatória de itens não-críticos

1.3 IMPORTANDO A BIBLIOTECA
--------------------------------------------------------------------------------
A biblioteca secrets faz parte da biblioteca padrão do Python 3.6+.

Importação básica:
import secrets

Importação específica:
from secrets import token_hex, token_urlsafe, choice

Verificando disponibilidade:
import sys
if sys.version_info >= (3, 6):
    import secrets
    print("secrets disponível!")
else:
    print("Atualize para Python 3.6+")


================================================================================
2. FUNÇÕES PRINCIPAIS DA BIBLIOTECA SECRETS
================================================================================

2.1 GERANDO NÚMEROS ALEATÓRIOS SEGUROS
--------------------------------------------------------------------------------
A biblioteca secrets oferece funções para gerar números inteiros seguros.

secrets.randbelow(n)
# Retorna um inteiro aleatório no intervalo [0, n)

Exemplos:
import secrets

# Número de 0 a 99
numero = secrets.randbelow(100)
print(numero)  # Exemplo: 42

# Simulando um dado de 6 faces
dado = secrets.randbelow(6) + 1
print(f"Você tirou: {dado}")  # 1 a 6

# Número de 10 a 99
numero = secrets.randbelow(90) + 10
print(numero)  # Exemplo: 73

Importante sobre randbelow():
- NÃO inclui o valor n (intervalo é [0, n))
- É mais seguro que random.randrange()
- Ideal para índices de arrays
- Evita viés de modulação

Comparação com random:
import random
import secrets

# random (NÃO seguro)
num1 = random.randrange(100)

# secrets (SEGURO)
num2 = secrets.randbelow(100)

2.2 GERANDO TOKENS HEXADECIMAIS
--------------------------------------------------------------------------------
secrets.token_hex(nbytes=None)
# Retorna uma string hexadecimal aleatória com nbytes bytes

Características:
- Retorna string com caracteres 0-9 e a-f
- Tamanho da string: 2 × nbytes caracteres
- Cada byte gera 2 caracteres hexadecimais

Exemplos básicos:
import secrets

# Token de 16 bytes (32 caracteres hex)
token = secrets.token_hex(16)
print(token)
# Exemplo: '3a7f5e9c1b2d8a4e6f0c9d3b7a5e1c8f'

# Token de 8 bytes (16 caracteres hex)
token_pequeno = secrets.token_hex(8)
print(token_pequeno)
# Exemplo: 'a1b2c3d4e5f67890'

# Token de 32 bytes (64 caracteres hex)
token_grande = secrets.token_hex(32)
print(token_grande)

Tamanho padrão (quando omitido):
token_padrao = secrets.token_hex()
print(len(token_padrao))  # Tamanho razoável e seguro

Casos de uso:
# ID de sessão
session_id = secrets.token_hex(16)

# Chave de API
api_key = secrets.token_hex(32)

# Token de verificação
verification_token = secrets.token_hex(24)

Validação de comprimento:
def gerar_token_sessao():
    # Gera token de 128 bits (16 bytes)
    token = secrets.token_hex(16)
    assert len(token) == 32  # 16 bytes × 2 = 32 chars
    return token

2.3 GERANDO TOKENS URL-SAFE
--------------------------------------------------------------------------------
secrets.token_urlsafe(nbytes=None)
# Retorna uma string aleatória segura para URLs

Características:
- Usa caracteres Base64 URL-safe: A-Z, a-z, 0-9, -, _
- Ideal para tokens em URLs
- Não precisa de encoding adicional
- Sem caracteres problemáticos (+, /, =)

Exemplos básicos:
import secrets

# Token URL-safe de 16 bytes
token = secrets.token_urlsafe(16)
print(token)
# Exemplo: 'Kx_7tL9mP-qR3vY8'

# Token para reset de senha
reset_token = secrets.token_urlsafe(32)
print(reset_token)
# Exemplo: 'aB3cD4eF5gH6iJ7kL8mN9oP0qR1sT2uV3wX4yZ5-_'

# Token curto
short_token = secrets.token_urlsafe(8)
print(short_token)
# Exemplo: 'x9YzA_bC'

Uso em URLs:
# Gerando link de verificação
def gerar_link_verificacao(email):
    token = secrets.token_urlsafe(32)
    base_url = "https://seusite.com/verificar"
    link = f"{base_url}?email={email}&token={token}"
    return link, token

link, token = gerar_link_verificacao("usuario@email.com")
print(link)
# https://seusite.com/verificar?email=usuario@email.com&token=xY9zA...

Comparação com token_hex:
hex_token = secrets.token_hex(16)      # 32 caracteres
url_token = secrets.token_urlsafe(16)  # ~22 caracteres

# token_urlsafe é mais compacto!
print(f"Hex: {len(hex_token)} chars")      # 32
print(f"URL-safe: {len(url_token)} chars") # ~22

2.4 GERANDO TOKENS DE BYTES
--------------------------------------------------------------------------------
secrets.token_bytes(nbytes=None)
# Retorna bytes aleatórios

Características:
- Retorna objeto bytes (não string)
- Útil para criptografia de baixo nível
- Precisa ser codificado para uso em texto

Exemplos básicos:
import secrets

# Gera 16 bytes aleatórios
token_bytes = secrets.token_bytes(16)
print(token_bytes)
# b'\x8a\x9f\x3c...'  (bytes brutos)

# Convertendo para hex
hex_str = token_bytes.hex()
print(hex_str)
# '8a9f3c...'

# Convertendo para base64
import base64
b64_str = base64.b64encode(token_bytes).decode('utf-8')
print(b64_str)

Casos de uso:
# Gerando salt para hashing
import hashlib

def hash_senha(senha):
    salt = secrets.token_bytes(32)
    pwd_hash = hashlib.pbkdf2_hmac(
        'sha256',
        senha.encode('utf-8'),
        salt,
        100000
    )
    return salt, pwd_hash

# Gerando chave de criptografia
chave_aes = secrets.token_bytes(32)  # 256 bits


================================================================================
3. ESCOLHA ALEATÓRIA SEGURA
================================================================================

3.1 ESCOLHENDO ELEMENTO DE SEQUÊNCIA
--------------------------------------------------------------------------------
secrets.choice(sequence)
# Retorna um elemento aleatório de uma sequência não-vazia

Funciona com:
- Listas
- Tuplas
- Strings
- Ranges
- Qualquer sequência

Exemplos básicos:
import secrets

# Escolher de uma lista
cores = ['vermelho', 'azul', 'verde', 'amarelo']
cor_escolhida = secrets.choice(cores)
print(cor_escolhida)  # Exemplo: 'verde'

# Escolher de uma string
vogais = 'aeiou'
vogal = secrets.choice(vogais)
print(vogal)  # Exemplo: 'i'

# Escolher de range
numero = secrets.choice(range(1, 101))
print(numero)  # Número de 1 a 100

# Escolher de tupla
dias = ('seg', 'ter', 'qua', 'qui', 'sex', 'sáb', 'dom')
dia = secrets.choice(dias)
print(dia)

ERRO COMUM - Sequência vazia:
# ❌ Isto dará erro!
lista_vazia = []
elemento = secrets.choice(lista_vazia)  # IndexError!

# ✅ Verificar antes
lista = []
if lista:
    elemento = secrets.choice(lista)
else:
    print("Lista vazia!")

3.2 GERANDO SENHAS SEGURAS
--------------------------------------------------------------------------------
Usando secrets.choice() para criar senhas fortes.

Exemplo básico:
import secrets
import string

# Caracteres disponíveis
alfabeto = string.ascii_letters + string.digits + string.punctuation

# Gerar senha de 12 caracteres
senha = ''.join(secrets.choice(alfabeto) for i in range(12))
print(senha)
# Exemplo: 'aK9$mP2@xL5!'

Função completa de geração de senha:
def gerar_senha(tamanho=12, 
                usar_maiusculas=True,
                usar_minusculas=True, 
                usar_numeros=True,
                usar_simbolos=True):
    """
    Gera uma senha aleatória segura.
    
    Args:
        tamanho: comprimento da senha
        usar_maiusculas: incluir A-Z
        usar_minusculas: incluir a-z
        usar_numeros: incluir 0-9
        usar_simbolos: incluir símbolos especiais
    
    Returns:
        String com a senha gerada
    """
    caracteres = ''
    
    if usar_maiusculas:
        caracteres += string.ascii_uppercase
    if usar_minusculas:
        caracteres += string.ascii_lowercase
    if usar_numeros:
        caracteres += string.digits
    if usar_simbolos:
        caracteres += string.punctuation
    
    if not caracteres:
        raise ValueError("Pelo menos um tipo de caractere deve ser usado!")
    
    senha = ''.join(secrets.choice(caracteres) for i in range(tamanho))
    return senha

# Exemplos de uso
senha1 = gerar_senha(16)
print(senha1)  # Senha de 16 caracteres

senha2 = gerar_senha(8, usar_simbolos=False)
print(senha2)  # Senha de 8 caracteres sem símbolos

senha3 = gerar_senha(20, usar_maiusculas=True, usar_minusculas=False)
print(senha3)  # Senha de 20 caracteres, só maiúsculas/números/símbolos

Garantindo tipos de caracteres:
def gerar_senha_forte(tamanho=12):
    """Garante pelo menos um de cada tipo de caractere."""
    if tamanho < 4:
        raise ValueError("Tamanho mínimo é 4")
    
    # Garante pelo menos um de cada
    senha = [
        secrets.choice(string.ascii_uppercase),
        secrets.choice(string.ascii_lowercase),
        secrets.choice(string.digits),
        secrets.choice(string.punctuation)
    ]
    
    # Preenche o resto
    todos_caracteres = (string.ascii_letters + 
                       string.digits + 
                       string.punctuation)
    
    senha.extend(secrets.choice(todos_caracteres) 
                for i in range(tamanho - 4))
    
    # Embaralha
    secrets.SystemRandom().shuffle(senha)
    
    return ''.join(senha)

senha_forte = gerar_senha_forte(16)
print(senha_forte)

Senha com palavras:
def gerar_senha_palavras(num_palavras=4):
    """Gera senha estilo diceware (fácil de lembrar)."""
    palavras = [
        'casa', 'gato', 'sol', 'mar', 'lua', 'rio',
        'flor', 'ceu', 'vento', 'pedra', 'livro', 'mesa'
    ]
    
    senha_palavras = [secrets.choice(palavras) 
                     for _ in range(num_palavras)]
    
    # Adiciona números e símbolos
    senha_palavras.append(str(secrets.randbelow(100)))
    senha_palavras.append(secrets.choice('!@#$%'))
    
    return '-'.join(senha_palavras)

senha_palavras = gerar_senha_palavras(3)
print(senha_palavras)
# Exemplo: 'casa-lua-rio-42-@'

3.3 GERANDO PINS E CÓDIGOS NUMÉRICOS
--------------------------------------------------------------------------------
Criando PINs seguros para autenticação.

PIN de 4 dígitos:
import secrets

def gerar_pin_4():
    """Gera PIN de 4 dígitos."""
    return ''.join(str(secrets.randbelow(10)) for _ in range(4))

pin = gerar_pin_4()
print(pin)  # Exemplo: '7392'

PIN de tamanho variável:
def gerar_pin(tamanho=6):
    """Gera PIN numérico de tamanho especificado."""
    if tamanho < 1:
        raise ValueError("Tamanho deve ser >= 1")
    
    return ''.join(str(secrets.randbelow(10)) for _ in range(tamanho))

pin_6 = gerar_pin(6)
print(pin_6)  # Exemplo: '482957'

pin_8 = gerar_pin(8)
print(pin_8)  # Exemplo: '18472639'

PIN sem repetição de dígitos:
def gerar_pin_unico(tamanho=4):
    """Gera PIN sem dígitos repetidos."""
    if tamanho > 10:
        raise ValueError("Tamanho máximo é 10 (0-9)")
    
    digitos = list(range(10))
    pin = []
    
    for _ in range(tamanho):
        idx = secrets.randbelow(len(digitos))
        pin.append(str(digitos.pop(idx)))
    
    return ''.join(pin)

pin_unico = gerar_pin_unico(4)
print(pin_unico)  # Exemplo: '5829' (sem repetição)

Código de verificação:
def gerar_codigo_verificacao():
    """Gera código de 6 dígitos para verificação."""
    codigo = gerar_pin(6)
    
    # Formata como XXX-XXX
    return f"{codigo[:3]}-{codigo[3:]}"

codigo = gerar_codigo_verificacao()
print(codigo)  # Exemplo: '482-957'

Código alfanumérico:
def gerar_codigo_alfanumerico(tamanho=8):
    """Gera código com letras e números."""
    alfabeto = string.ascii_uppercase + string.digits
    # Remove caracteres confusos: O/0, I/1
    alfabeto = alfabeto.replace('O', '').replace('I', '')
    
    return ''.join(secrets.choice(alfabeto) for _ in range(tamanho))

codigo = gerar_codigo_alfanumerico(8)
print(codigo)  # Exemplo: 'A7K9M2B4'


================================================================================
4. COMPARAÇÃO SEGURA DE STRINGS
================================================================================

4.1 SECRETS.COMPARE_DIGEST()
--------------------------------------------------------------------------------
secrets.compare_digest(a, b)
# Compara duas strings de forma segura contra timing attacks

Por que usar compare_digest?
Comparação normal (INSEGURA):
if token_usuario == token_correto:  # ❌ Vulnerável a timing attack
    # Acesso permitido

Comparação segura (SEGURA):
if secrets.compare_digest(token_usuario, token_correto):  # ✅ Seguro
    # Acesso permitido

O problema do timing attack:
# Comparação normal para em caractere diferente
# Atacante pode medir o tempo de resposta
"senha123" == "senha456"  # Para no 6º caractere (mais rápido)
"senha123" == "senhaxxx"  # Para no 5º caractere (rápido)
"senha123" == "senhayyy"  # Para no 5º caractere (rápido)
"senha123" == "senha1xx"  # Para no 7º caractere (mais lento)

# compare_digest sempre leva o mesmo tempo!

Exemplos básicos:
import secrets

# Comparando tokens
token_esperado = "abc123xyz"
token_recebido = "abc123xyz"

if secrets.compare_digest(token_esperado, token_recebido):
    print("Token válido!")
else:
    print("Token inválido!")

# Comparando senhas hash
senha_hash_db = "5f4dcc3b5aa765d61d8327deb882cf99"
senha_hash_input = "5f4dcc3b5aa765d61d8327deb882cf99"

if secrets.compare_digest(senha_hash_db, senha_hash_input):
    print("Senha correta!")

Funciona com bytes:
import hashlib

hash1 = hashlib.sha256(b"senha").digest()
hash2 = hashlib.sha256(b"senha").digest()

if secrets.compare_digest(hash1, hash2):
    print("Hashes idênticos!")

4.2 VALIDAÇÃO DE TOKENS
--------------------------------------------------------------------------------
Exemplo prático de validação de token de sessão.

Sistema básico de tokens:
import secrets
import time

# Armazenamento de tokens (em produção, use banco de dados)
tokens_validos = {}

def criar_token(user_id):
    """Cria um token de sessão para o usuário."""
    token = secrets.token_urlsafe(32)
    tokens_validos[token] = {
        'user_id': user_id,
        'criado_em': time.time()
    }
    return token

def validar_token(token, user_id):
    """Valida um token de sessão."""
    if token not in tokens_validos:
        return False
    
    dados = tokens_validos[token]
    
    # Verifica user_id com compare_digest
    user_id_str = str(user_id)
    user_id_token = str(dados['user_id'])
    
    if not secrets.compare_digest(user_id_str, user_id_token):
        return False
    
    # Verifica expiração (1 hora)
    idade = time.time() - dados['criado_em']
    if idade > 3600:  # 1 hora em segundos
        del tokens_validos[token]
        return False
    
    return True

# Uso
token = criar_token(123)
print(f"Token criado: {token}")

if validar_token(token, 123):
    print("Acesso permitido!")
else:
    print("Acesso negado!")

Sistema de API Key:
class APIKeyManager:
    def __init__(self):
        self.api_keys = {}
    
    def gerar_api_key(self, usuario):
        """Gera uma nova API key."""
        api_key = secrets.token_hex(32)
        self.api_keys[api_key] = {
            'usuario': usuario,
            'criada_em': time.time(),
            'ativa': True
        }
        return api_key
    
    def validar_api_key(self, api_key):
        """Valida uma API key."""
        # Verifica se existe
        if api_key not in self.api_keys:
            return False, None
        
        dados = self.api_keys[api_key]
        
        # Verifica se está ativa
        if not dados['ativa']:
            return False, None
        
        return True, dados['usuario']
    
    def revogar_api_key(self, api_key):
        """Revoga uma API key."""
        if api_key in self.api_keys:
            self.api_keys[api_key]['ativa'] = False
            return True
        return False

# Uso
manager = APIKeyManager()

# Criar chave
chave = manager.gerar_api_key("joao@email.com")
print(f"API Key: {chave}")

# Validar
valida, usuario = manager.validar_api_key(chave)
if valida:
    print(f"Acesso permitido para: {usuario}")

# Revogar
manager.revogar_api_key(chave)
print("Chave revogada!")


================================================================================
5. GERANDO IDENTIFICADORES ÚNICOS
================================================================================

5.1 IDS DE SESSÃO
--------------------------------------------------------------------------------
Gerando IDs únicos para sessões web.

ID de sessão simples:
import secrets

def gerar_session_id():
    """Gera um ID de sessão único."""
    return secrets.token_urlsafe(32)

session_id = gerar_session_id()
print(f"Session ID: {session_id}")

ID de sessão com timestamp:
import time

def gerar_session_id_timestamp():
    """Gera ID de sessão com timestamp embutido."""
    timestamp = int(time.time())
    token = secrets.token_hex(16)
    return f"{timestamp}_{token}"

session_id = gerar_session_id_timestamp()
print(session_id)
# Exemplo: '1701234567_a1b2c3d4e5f67890a1b2c3d4e5f67890'

Gerenciador de sessões:
class SessionManager:
    def __init__(self):
        self.sessoes = {}
    
    def criar_sessao(self, user_id):
        """Cria uma nova sessão."""
        session_id = secrets.token_urlsafe(32)
        
        self.sessoes[session_id] = {
            'user_id': user_id,
            'criada': time.time(),
            'ultimo_acesso': time.time()
        }
        
        return session_id
    
    def validar_sessao(self, session_id):
        """Valida uma sessão existente."""
        if session_id not in self.sessoes:
            return False, None
        
        sessao = self.sessoes[session_id]
        
        # Verifica expiração (30 minutos)
        tempo_inativo = time.time() - sessao['ultimo_acesso']
        if tempo_inativo > 1800:  # 30 minutos
            del self.sessoes[session_id]
            return False, None
        
        # Atualiza último acesso
        sessao['ultimo_acesso'] = time.time()
        
        return True, sessao['user_id']
    
    def encerrar_sessao(self, session_id):
        """Encerra uma sessão."""
        if session_id in self.sessoes:
            del self.sessoes[session_id]
            return True
        return False
    
    def limpar_sessoes_expiradas(self):
        """Remove sessões expiradas."""
        agora = time.time()
        expiradas = [
            sid for sid, dados in self.sessoes.items()
            if agora - dados['ultimo_acesso'] > 1800
        ]
        
        for sid in expiradas:
            del self.sessoes[sid]
        
        return len(expiradas)

# Uso
sm = SessionManager()

# Criar sessão
sid = sm.criar_sessao(user_id=123)
print(f"Sessão criada: {sid}")

# Validar
valida, user_id = sm.validar_sessao(sid)
if valida:
    print(f"Sessão válida para usuário {user_id}")

# Encerrar
sm.encerrar_sessao(sid)
print("Sessão encerrada!")

5.2 IDS DE TRANSAÇÃO
--------------------------------------------------------------------------------
Gerando IDs únicos para transações financeiras ou operações.

ID de transação básico:
def gerar_transaction_id():
    """Gera ID de transação único."""
    # Formato: TXN-TIMESTAMP-RANDOM
    timestamp = int(time.time())
    random_part = secrets.token_hex(8)
    return f"TXN-{timestamp}-{random_part}"

txn_id = gerar_transaction_id()
print(txn_id)
# Exemplo: 'TXN-1701234567-a1b2c3d4e5f67890'

ID de pedido:
def gerar_order_id(prefixo="ORD"):
    """Gera ID de pedido."""
    numero = secrets.randbelow(1000000)
    random_suffix = secrets.token_hex(4)
    return f"{prefixo}-{numero:06d}-{random_suffix}"

order_id = gerar_order_id()
print(order_id)
# Exemplo: 'ORD-482957-a1b2c3d4'

ID de rastreamento:
import datetime

def gerar_tracking_id():
    """Gera ID de rastreamento de envio."""
    data = datetime.datetime.now().strftime("%Y%m%d")
    sequencia = secrets.randbelow(10000)
    verificador = secrets.randbelow(100)
    
    return f"BR{data}{sequencia:04d}{verificador:02d}"

tracking = gerar_tracking_id()
print(tracking)
# Exemplo: 'BR20231129482957'

5.3 CÓDIGOS DE CUPOM E VOUCHER
--------------------------------------------------------------------------------
Gerando códigos promocionais únicos.

Código de cupom básico:
def gerar_cupom(prefixo="PROMO", tamanho=8):
    """Gera código de cupom alfanumérico."""
    # Usa apenas letras maiúsculas e números (exceto confusos)
    alfabeto = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'
    codigo = ''.join(secrets.choice(alfabeto) for _ in range(tamanho))
    return f"{prefixo}{codigo}"

cupom = gerar_cupom()
print(cupom)
# Exemplo: 'PROMOK7M9B2X4'

Código de vale-presente:
def gerar_gift_card():
    """Gera código de vale-presente de 16 dígitos."""
    # Formato: XXXX-XXXX-XXXX-XXXX
    grupos = []
    for _ in range(4):
        grupo = ''.join(str(secrets.randbelow(10)) for _ in range(4))
        grupos.append(grupo)
    
    return '-'.join(grupos)

gift_card = gerar_gift_card()
print(gift_card)
# Exemplo: '4829-5718-3642-9057'

Gerador de lote de cupons:
def gerar_lote_cupons(quantidade, desconto, prefixo="DESC"):
    """Gera lote de cupons únicos."""
    cupons = set()
    
    while len(cupons) < quantidade:
        cupom = gerar_cupom(prefixo=f"{prefixo}{desconto}")
        cupons.add(cupom)
    
    return list(cupons)

# Gerar 100 cupons de 20% de desconto
cupons_20 = gerar_lote_cupons(100, 20)
print(f"Gerados {len(cupons_20)} cupons:")
for i, cupom in enumerate(cupons_20[:5], 1):
    print(f"{i}. {cupom}")
# Exemplo:
# 1. DESC20K7M9B2X4
# 2. DESC20P3Q8R5T9
# ...


================================================================================
6. PRÁTICAS DE SEGURANÇA E MELHORES USOS
================================================================================

6.1 ESCOLHENDO O TAMANHO CORRETO
--------------------------------------------------------------------------------
Guia de tamanhos recomendados para diferentes usos.

Tamanhos em bytes e bits:
8 bytes   = 64 bits   = segurança baixa (não recomendado)
16 bytes  = 128 bits  = segurança adequada para maioria dos casos
32 bytes  = 256 bits  = segurança alta
64 bytes  = 512 bits  = segurança muito alta (overkill para maioria)

Recomendações por caso de uso:

# Session IDs: 16-32 bytes
session_id = secrets.token_urlsafe(32)  # Recomendado

# API Keys: 32 bytes
api_key = secrets.token_hex(32)

# Tokens de reset de senha: 32 bytes
reset_token = secrets.token_urlsafe(32)

# CSRF tokens: 16-32 bytes
csrf_token = secrets.token_hex(16)

# Códigos de verificação: 6 dígitos
codigo = gerar_pin(6)

# Senhas: 12-16 caracteres
senha = gerar_senha(16)

Evitando tamanhos inseguros:
# ❌ MUITO CURTO (inseguro)
token_curto = secrets.token_hex(4)  # Apenas 8 chars!

# ❌ MUITO LONGO (desnecessário)
token_longo = secrets.token_hex(128)  # 256 chars!

# ✅ TAMANHO ADEQUADO
token_bom = secrets.token_hex(16)  # 32 chars

Calculando entropia:
import math

def calcular_entropia_bits(tamanho_bytes):
    """Calcula bits de entropia."""
    return tamanho_bytes * 8

def tempo_brute_force(entropia_bits, tentativas_por_segundo=1e9):
    """Estima tempo para quebrar por força bruta."""
    total_combinacoes = 2 ** entropia_bits
    segundos = total_combinacoes / tentativas_por_segundo
    
    anos = segundos / (365.25 * 24 * 3600)
    
    return anos

# Exemplos
print(f"16 bytes: {calcular_entropia_bits(16)} bits")
print(f"Tempo estimado: {tempo_brute_force(128):.2e} anos")
# 16 bytes: 128 bits
# Tempo estimado: 1.08e+22 anos (muito seguro!)

6.2 ARMAZENAMENTO SEGURO
--------------------------------------------------------------------------------
Nunca armazene tokens em texto plano!

❌ INSEGURO - Armazenar token direto:
# NO BANCO DE DADOS
# tokens: id | user_id | token
# 1 | 123 | "abc123xyz789..."  ← NUNCA FAÇA ISSO!

✅ SEGURO - Armazenar hash do token:
import hashlib

def criar_token_com_hash(user_id):
    """Cria token e armazena apenas o hash."""
    # Gera token
    token = secrets.token_urlsafe(32)
    
    # Hash do token para armazenar
    token_hash = hashlib.sha256(token.encode()).hexdigest()
    
    # Salvar no banco: user_id, token_hash, criado_em
    # Retorna token original para o usuário (única vez!)
    return token

def validar_token_hash(token_recebido, token_hash_db):
    """Valida token comparando hashes."""
    # Hash do token recebido
    hash_recebido = hashlib.sha256(token_recebido.encode()).hexdigest()
    
    # Compara com hash armazenado
    return secrets.compare_digest(hash_recebido, token_hash_db)

Sistema completo de tokens:
class TokenSeguro:
    def __init__(self):
        self.tokens = {}  # Em produção: usar banco de dados
    
    def criar_token(self, user_id, tipo="session"):
        """Cria um token seguro."""
        # Gera token
        token = secrets.token_urlsafe(32)
        
        # Hash para armazenar
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # Armazena apenas o hash
        self.tokens[token_hash] = {
            'user_id': user_id,
            'tipo': tipo,
            'criado': time.time()
        }
        
        # Retorna token original (única vez!)
        return token
    
    def validar_token(self, token, tipo_esperado="session"):
        """Valida um token."""
        # Hash do token recebido
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # Verifica se existe
        if token_hash not in self.tokens:
            return False, None
        
        dados = self.tokens[token_hash]
        
        # Verifica tipo
        if dados['tipo'] != tipo_esperado:
            return False, None
        
        return True, dados['user_id']
    
    def revogar_token(self, token):
        """Revoga um token."""
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        if token_hash in self.tokens:
            del self.tokens[token_hash]
            return True
        return False

6.3 TOKENS COM EXPIRAÇÃO
--------------------------------------------------------------------------------
Implementando tokens que expiram automaticamente.

Token com timestamp embutido:
import json
import base64

def criar_token_expiravel(user_id, validade_segundos=3600):
    """Cria token que expira após tempo especificado."""
    # Dados do token
    dados = {
        'user_id': user_id,
        'expira_em': time.time() + validade_segundos,
        'random': secrets.token_hex(16)
    }
    
    # Serializa e codifica
    dados_json = json.dumps(dados)
    token_b64 = base64.urlsafe_b64encode(dados_json.encode()).decode()
    
    return token_b64

def validar_token_expiravel(token):
    """Valida token e verifica expiração."""
    try:
        # Decodifica
        dados_json = base64.urlsafe_b64decode(token.encode()).decode()
        dados = json.loads(dados_json)
        
        # Verifica expiração
        if time.time() > dados['expira_em']:
            return False, None, "Token expirado"
        
        return True, dados['user_id'], "OK"
        
    except Exception as e:
        return False, None, f"Token inválido: {str(e)}"

# Uso
token = criar_token_expiravel(123, validade_segundos=300)  # 5 minutos
print(f"Token: {token}")

# Validar imediatamente
valido, user_id, msg = validar_token_expiravel(token)
print(f"Válido: {valido}, User: {user_id}, Msg: {msg}")

# Aguardar expiração...
time.sleep(301)
valido, user_id, msg = validar_token_expiravel(token)
print(f"Válido: {valido}, Msg: {msg}")  # Token expirado

Sistema de refresh tokens:
class RefreshTokenSystem:
    def __init__(self):
        self.access_tokens = {}
        self.refresh_tokens = {}
    
    def criar_tokens(self, user_id):
        """Cria par de access e refresh tokens."""
        # Access token (curta duração - 15 min)
        access_token = secrets.token_urlsafe(32)
        access_hash = hashlib.sha256(access_token.encode()).hexdigest()
        
        self.access_tokens[access_hash] = {
            'user_id': user_id,
            'expira': time.time() + 900  # 15 minutos
        }
        
        # Refresh token (longa duração - 7 dias)
        refresh_token = secrets.token_urlsafe(32)
        refresh_hash = hashlib.sha256(refresh_token.encode()).hexdigest()
        
        self.refresh_tokens[refresh_hash] = {
            'user_id': user_id,
            'expira': time.time() + 604800  # 7 dias
        }
        
        return access_token, refresh_token
    
    def validar_access_token(self, token):
        """Valida access token."""
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        if token_hash not in self.access_tokens:
            return False, None, "Token não encontrado"
        
        dados = self.access_tokens[token_hash]
        
        if time.time() > dados['expira']:
            del self.access_tokens[token_hash]
            return False, None, "Token expirado"
        
        return True, dados['user_id'], "OK"
    
    def renovar_access_token(self, refresh_token):
        """Renova access token usando refresh token."""
        refresh_hash = hashlib.sha256(refresh_token.encode()).hexdigest()
        
        if refresh_hash not in self.refresh_tokens:
            return None, "Refresh token inválido"
        
        dados = self.refresh_tokens[refresh_hash]
        
        if time.time() > dados['expira']:
            del self.refresh_tokens[refresh_hash]
            return None, "Refresh token expirado"
        
        # Cria novo access token
        novo_access = secrets.token_urlsafe(32)
        access_hash = hashlib.sha256(novo_access.encode()).hexdigest()
        
        self.access_tokens[access_hash] = {
            'user_id': dados['user_id'],
            'expira': time.time() + 900
        }
        
        return novo_access, "OK"

6.4 RATE LIMITING COM SECRETS
--------------------------------------------------------------------------------
Implementando limitação de taxa para prevenir abuso.

Sistema de rate limiting básico:
import collections

class RateLimiter:
    def __init__(self, max_tentativas=5, janela_segundos=60):
        self.max_tentativas = max_tentativas
        self.janela = janela_segundos
        self.tentativas = collections.defaultdict(list)
    
    def pode_tentar(self, identificador):
        """Verifica se pode fazer nova tentativa."""
        agora = time.time()
        
        # Remove tentativas antigas
        self.tentativas[identificador] = [
            t for t in self.tentativas[identificador]
            if agora - t < self.janela
        ]
        
        # Verifica limite
        if len(self.tentativas[identificador]) >= self.max_tentativas:
            return False
        
        # Registra tentativa
        self.tentativas[identificador].append(agora)
        return True
    
    def tempo_ate_reset(self, identificador):
        """Retorna tempo até poder tentar novamente."""
        if identificador not in self.tentativas:
            return 0
        
        tentativas = self.tentativas[identificador]
        if not tentativas:
            return 0
        
        tempo_decorrido = time.time() - tentativas[0]
        return max(0, self.janela - tempo_decorrido)

# Uso em sistema de login
limiter = RateLimiter(max_tentativas=3, janela_segundos=300)

def fazer_login(username, password):
    """Tenta fazer login com rate limiting."""
    # Verifica rate limit
    if not limiter.pode_tentar(username):
        tempo_restante = limiter.tempo_ate_reset(username)
        return False, f"Muitas tentativas. Aguarde {tempo_restante:.0f}s"
    
    # Simula validação de senha
    # (em produção: verificar hash no banco)
    senha_correta = "senha123"
    
    if password == senha_correta:
        return True, "Login bem-sucedido!"
    else:
        return False, "Senha incorreta"

# Teste
for i in range(5):
    sucesso, msg = fazer_login("usuario", "senha_errada")
    print(f"Tentativa {i+1}: {msg}")


================================================================================
7. EXEMPLOS PRÁTICOS COMPLETOS
================================================================================

7.1 SISTEMA DE AUTENTICAÇÃO BÁSICO
--------------------------------------------------------------------------------
import secrets
import hashlib
import time

class SistemaAutenticacao:
    def __init__(self):
        self.usuarios = {}  # user_id: {username, password_hash, salt}
        self.sessoes = {}   # session_id: {user_id, expira}
    
    def registrar_usuario(self, username, password):
        """Registra novo usuário."""
        # Verifica se usuário já existe
        if any(u['username'] == username for u in self.usuarios.values()):
            return False, "Usuário já existe"
        
        # Gera salt único
        salt = secrets.token_bytes(32)
        
        # Hash da senha com salt
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt,
            100000  # iterações
        )
        
        # Gera ID único
        user_id = secrets.token_hex(16)
        
        # Armazena usuário
        self.usuarios[user_id] = {
            'username': username,
            'password_hash': password_hash,
            'salt': salt
        }
        
        return True, user_id
    
    def fazer_login(self, username, password):
        """Autentica usuário e cria sessão."""
        # Encontra usuário
        user_id = None
        user_data = None
        
        for uid, data in self.usuarios.items():
            if data['username'] == username:
                user_id = uid
                user_data = data
                break
        
        if not user_data:
            return False, None, "Usuário não encontrado"
        
        # Verifica senha
        password_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            user_data['salt'],
            100000
        )
        
        if not secrets.compare_digest(password_hash, user_data['password_hash']):
            return False, None, "Senha incorreta"
        
        # Cria sessão
        session_id = secrets.token_urlsafe(32)
        self.sessoes[session_id] = {
            'user_id': user_id,
            'expira': time.time() + 3600  # 1 hora
        }
        
        return True, session_id, "Login bem-sucedido"
    
    def validar_sessao(self, session_id):
        """Valida sessão existente."""
        if session_id not in self.sessoes:
            return False, None, "Sessão inválida"
        
        sessao = self.sessoes[session_id]
        
        if time.time() > sessao['expira']:
            del self.sessoes[session_id]
            return False, None, "Sessão expirada"
        
        return True, sessao['user_id'], "Sessão válida"
    
    def fazer_logout(self, session_id):
        """Encerra sessão."""
        if session_id in self.sessoes:
            del self.sessoes[session_id]
            return True, "Logout bem-sucedido"
        return False, "Sessão não encontrada"

# Exemplo de uso
auth = SistemaAutenticacao()

# Registrar usuário
sucesso, user_id = auth.registrar_usuario("joao", "senha_forte_123")
print(f"Registro: {sucesso}, ID: {user_id}")

# Login
sucesso, session_id, msg = auth.fazer_login("joao", "senha_forte_123")
print(f"Login: {msg}, Session: {session_id}")

# Validar sessão
valido, uid, msg = auth.validar_sessao(session_id)
print(f"Validação: {msg}, User ID: {uid}")

# Logout
sucesso, msg = auth.fazer_logout(session_id)
print(f"Logout: {msg}")

7.2 GERADOR DE CÓDIGOS DE VERIFICAÇÃO 2FA
--------------------------------------------------------------------------------
import secrets
import time
import hashlib

class Sistema2FA:
    def __init__(self):
        self.codigos_pendentes = {}
    
    def gerar_codigo_2fa(self, user_id):
        """Gera código de 6 dígitos para 2FA."""
        # Gera código
        codigo = ''.join(str(secrets.randbelow(10)) for _ in range(6))
        
        # Hash para armazenar
        codigo_hash = hashlib.sha256(codigo.encode()).hexdigest()
        
        # Armazena com expiração (5 minutos)
        self.codigos_pendentes[user_id] = {
            'codigo_hash': codigo_hash,
            'expira': time.time() + 300,
            'tentativas': 0
        }
        
        # Retorna código para enviar ao usuário (SMS/email)
        return codigo
    
    def validar_codigo_2fa(self, user_id, codigo_digitado):
        """Valida código 2FA."""
        if user_id not in self.codigos_pendentes:
            return False, "Código não encontrado"
        
        dados = self.codigos_pendentes[user_id]
        
        # Verifica expiração
        if time.time() > dados['expira']:
            del self.codigos_pendentes[user_id]
            return False, "Código expirado"
        
        # Limita tentativas
        if dados['tentativas'] >= 3:
            del self.codigos_pendentes[user_id]
            return False, "Muitas tentativas. Solicite novo código"
        
        # Incrementa tentativas
        dados['tentativas'] += 1
        
        # Valida código
        codigo_hash = hashlib.sha256(codigo_digitado.encode()).hexdigest()
        
        if secrets.compare_digest(codigo_hash, dados['codigo_hash']):
            del self.codigos_pendentes[user_id]
            return True, "Código válido!"
        
        return False, "Código incorreto"
    
    def reenviar_codigo(self, user_id):
        """Gera novo código (invalida o anterior)."""
        if user_id in self.codigos_pendentes:
            del self.codigos_pendentes[user_id]
        
        return self.gerar_codigo_2fa(user_id)

# Uso
sistema_2fa = Sistema2FA()

# Simular login
user_id = "user_123"

# Gerar código
codigo = sistema_2fa.gerar_codigo_2fa(user_id)
print(f"Código 2FA gerado: {codigo}")
print("(Enviado por SMS/Email)")

# Usuário digita código
codigo_digitado = input("Digite o código recebido: ")

# Validar
valido, msg = sistema_2fa.validar_codigo_2fa(user_id, codigo_digitado)
print(f"Validação: {msg}")

7.3 SISTEMA DE RESET DE SENHA
--------------------------------------------------------------------------------
class SistemaResetSenha:
    def __init__(self):
        self.tokens_reset = {}
    
    def solicitar_reset(self, email):
        """Cria token de reset de senha."""
        # Gera token único
        token = secrets.token_urlsafe(32)
        
        # Hash para armazenar
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        # Armazena com expiração (1 hora)
        self.tokens_reset[token_hash] = {
            'email': email,
            'expira': time.time() + 3600,
            'usado': False
        }
        
        # Retorna token para enviar por email
        return token
    
    def validar_token_reset(self, token):
        """Valida token de reset."""
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        
        if token_hash not in self.tokens_reset:
            return False, None, "Token inválido"
        
        dados = self.tokens_reset[token_hash]
        
        # Verifica se já foi usado
        if dados['usado']:
            return False, None, "Token já utilizado"
        
        # Verifica expiração
        if time.time() > dados['expira']:
            del self.tokens_reset[token_hash]
            return False, None, "Token expirado"
        
        return True, dados['email'], "Token válido"
    
    def redefinir_senha(self, token, nova_senha):
        """Redefine senha usando token."""
        valido, email, msg = self.validar_token_reset(token)
        
        if not valido:
            return False, msg
        
        # Marca token como usado
        token_hash = hashlib.sha256(token.encode()).hexdigest()
        self.tokens_reset[token_hash]['usado'] = True
        
        # Aqui você atualizaria a senha no banco de dados
        # salt = secrets.token_bytes(32)
        # password_hash = hashlib.pbkdf2_hmac(...)
        
        return True, f"Senha redefinida para {email}"

# Uso
reset_sistema = SistemaResetSenha()

# Usuário solicita reset
email = "usuario@email.com"
token = reset_sistema.solicitar_reset(email)
print(f"Token de reset: {token}")
print(f"Link: https://seusite.com/reset?token={token}")

# Usuário clica no link e define nova senha
valido, email, msg = reset_sistema.validar_token_reset(token)
if valido:
    sucesso, msg = reset_sistema.redefinir_senha(token, "nova_senha_123")
    print(msg)

7.4 GERADOR DE CÓDIGOS PROMOCIONAIS
--------------------------------------------------------------------------------
class GeradorCupons:
    def __init__(self):
        self.cupons = {}
    
    def gerar_cupom(self, desconto, quantidade_usos=1, validade_dias=30):
        """Gera código de cupom único."""
        # Gera código
        alfabeto = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'
        codigo = ''.join(secrets.choice(alfabeto) for _ in range(8))
        codigo_completo = f"DESC{desconto}-{codigo}"
        
        # Armazena informações
        self.cupons[codigo_completo] = {
            'desconto': desconto,
            'usos_restantes': quantidade_usos,
            'expira': time.time() + (validade_dias * 86400),
            'ativo': True
        }
        
        return codigo_completo
    
    def validar_cupom(self, codigo):
        """Valida e aplica cupom."""
        if codigo not in self.cupons:
            return False, 0, "Cupom inválido"
        
        cupom = self.cupons[codigo]
        
        if not cupom['ativo']:
            return False, 0, "Cupom desativado"
        
        if time.time() > cupom['expira']:
            return False, 0, "Cupom expirado"
        
        if cupom['usos_restantes'] <= 0:
            return False, 0, "Cupom esgotado"
        
        # Decrementa usos
        cupom['usos_restantes'] -= 1
        
        return True, cupom['desconto'], "Cupom aplicado!"
    
    def gerar_lote(self, quantidade, desconto, usos_por_cupom=1):
        """Gera lote de cupons."""
        cupons = []
        for _ in range(quantidade):
            cupom = self.gerar_cupom(desconto, usos_por_cupom)
            cupons.append(cupom)
        return cupons
    
    def desativar_cupom(self, codigo):
        """Desativa um cupom."""
        if codigo in self.cupons:
            self.cupons[codigo]['ativo'] = False
            return True
        return False

# Uso
gerador = GeradorCupons()

# Gerar cupom único de 20%
cupom = gerador.gerar_cupom(desconto=20, quantidade_usos=1, validade_dias=30)
print(f"Cupom gerado: {cupom}")

# Gerar lote de 100 cupons de 15%
lote = gerador.gerar_lote(quantidade=100, desconto=15, usos_por_cupom=1)
print(f"Gerados {len(lote)} cupons")
print("Primeiros 5:")
for i, c in enumerate(lote[:5], 1):
    print(f"{i}. {c}")

# Validar cupom
valido, desconto, msg = gerador.validar_cupom(cupom)
print(f"Validação: {msg}, Desconto: {desconto}%")

7.5 SISTEMA DE CONVITES
--------------------------------------------------------------------------------
class SistemaConvites:
    def __init__(self):
        self.convites = {}
    
    def gerar_convite(self, convidado_por, email_destinatario=None, 
                     max_usos=1, validade_dias=7):
        """Gera código de convite."""
        # Gera código único
        codigo = secrets.token_urlsafe(16)
        
        # Armazena informações
        self.convites[codigo] = {
            'convidado_por': convidado_por,
            'email_destinatario': email_destinatario,
            'max_usos': max_usos,
            'usos': 0,
            'expira': time.time() + (validade_dias * 86400),
            'usado_por': []
        }
        
        return codigo
    
    def aceitar_convite(self, codigo, novo_usuario_email):
        """Aceita um convite."""
        if codigo not in self.convites:
            return False, "Convite inválido"
        
        convite = self.convites[codigo]
        
        # Verifica expiração
        if time.time() > convite['expira']:
            return False, "Convite expirado"
        
        # Verifica limite de usos
        if convite['usos'] >= convite['max_usos']:
            return False, "Convite já utilizado"
        
        # Verifica se é destinatário específico
        if convite['email_destinatario']:
            if novo_usuario_email != convite['email_destinatario']:
                return False, "Convite não é para este email"
        
        # Verifica se já usou
        if novo_usuario_email in convite['usado_por']:
            return False, "Você já usou este convite"
        
        # Registra uso
        convite['usos'] += 1
        convite['usado_por'].append(novo_usuario_email)
        
        return True, f"Convite aceito! Convidado por: {convite['convidado_por']}"
    
    def listar_convites_usuario(self, user_id):
        """Lista convites criados por um usuário."""
        convites_usuario = []
        
        for codigo, dados in self.convites.items():
            if dados['convidado_por'] == user_id:
                convites_usuario.append({
                    'codigo': codigo,
                    'usos': f"{dados['usos']}/{dados['max_usos']}",
                    'email': dados['email_destinatario'],
                    'expira': dados['expira']
                })
        
        return convites_usuario

# Uso
sistema = SistemaConvites()

# Usuário cria convite
user_id = "user_123"
codigo = sistema.gerar_convite(
    convidado_por=user_id,
    email_destinatario="amigo@email.com",
    max_usos=1,
    validade_dias=7
)
print(f"Código de convite: {codigo}")
print(f"Link: https://seusite.com/registro?convite={codigo}")

# Novo usuário aceita convite
aceito, msg = sistema.aceitar_convite(codigo, "amigo@email.com")
print(f"Aceitação: {msg}")

# Listar convites do usuário
meus_convites = sistema.listar_convites_usuario(user_id)
print(f"Meus convites: {len(meus_convites)}")


================================================================================
8. SEGURANÇA AVANÇADA
================================================================================

8.1 PROTEÇÃO CONTRA TIMING ATTACKS
--------------------------------------------------------------------------------
Por que timing attacks são perigosos?

Comparação insegura (vulnerável):
def login_inseguro(username, password):
    senha_correta = "senha123"
    
    # ❌ Comparação normal para no primeiro caractere diferente
    if password == senha_correta:
        return True
    return False

# Atacante pode medir tempo de resposta:
# "a" vs "senha123" → muito rápido (1 char)
# "s" vs "senha123" → rápido (1 char)
# "se" vs "senha123" → um pouco mais lento (2 chars)
# "senha" vs "senha123" → mais lento (5 chars)

Comparação segura (protegida):
def login_seguro(username, password):
    senha_correta_hash = hashlib.sha256("senha123".encode()).digest()
    senha_input_hash = hashlib.sha256(password.encode()).digest()
    
    # ✅ compare_digest sempre leva o mesmo tempo
    if secrets.compare_digest(senha_correta_hash, senha_input_hash):
        return True
    return False

Exemplo completo:
import secrets
import hashlib
import time

class LoginSeguro:
    def __init__(self):
        self.usuarios = {
            'admin': {
                'salt': secrets.token_bytes(32),
                'hash': b''  # será preenchido
            }
        }
        # Cria hash da senha
        senha = 'admin123'
        self.usuarios['admin']['hash'] = hashlib.pbkdf2_hmac(
            'sha256',
            senha.encode(),
            self.usuarios['admin']['salt'],
            100000
        )
    
    def fazer_login_inseguro(self, username, password):
        """Login vulnerável a timing attack."""
        if username not in self.usuarios:
            return False
        
        user = self.usuarios[username]
        
        # Calcula hash da senha fornecida
        senha_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            user['salt'],
            100000
        )
        
        # ❌ INSEGURO: comparação normal
        if senha_hash == user['hash']:
            return True
        return False
    
    def fazer_login_seguro(self, username, password):
        """Login protegido contra timing attack."""
        if username not in self.usuarios:
            # Faz cálculo mesmo se usuário não existir
            # para manter tempo constante
            fake_salt = secrets.token_bytes(32)
            hashlib.pbkdf2_hmac('sha256', password.encode(), fake_salt, 100000)
            return False
        
        user = self.usuarios[username]
        
        # Calcula hash da senha fornecida
        senha_hash = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode(),
            user['salt'],
            100000
        )
        
        # ✅ SEGURO: usa compare_digest
        if secrets.compare_digest(senha_hash, user['hash']):
            return True
        return False

# Demonstração
login = LoginSeguro()

# Medir tempo de login inseguro
inicio = time.perf_counter()
login.fazer_login_inseguro('admin', 'a')
tempo_1char = time.perf_counter() - inicio

inicio = time.perf_counter()
login.fazer_login_inseguro('admin', 'admin1')
tempo_6chars = time.perf_counter() - inicio

print(f"Inseguro - 1 char: {tempo_1char:.6f}s")
print(f"Inseguro - 6 chars: {tempo_6chars:.6f}s")
print(f"Diferença: {abs(tempo_1char - tempo_6chars):.6f}s")

# Medir tempo de login seguro
inicio = time.perf_counter()
login.fazer_login_seguro('admin', 'a')
tempo_1char_seguro = time.perf_counter() - inicio

inicio = time.perf_counter()
login.fazer_login_seguro('admin', 'admin1')
tempo_6chars_seguro = time.perf_counter() - inicio

print(f"\nSeguro - 1 char: {tempo_1char_seguro:.6f}s")
print(f"Seguro - 6 chars: {tempo_6chars_seguro:.6f}s")
print(f"Diferença: {abs(tempo_1char_seguro - tempo_6chars_seguro):.6f}s")

8.2 DERIVAÇÃO DE CHAVES (KDF)
--------------------------------------------------------------------------------
Usando secrets com funções de derivação de chaves.

PBKDF2 com secrets:
import hashlib
import secrets

def derivar_chave(senha, salt=None, iteracoes=100000):
    """Deriva chave criptográfica de uma senha."""
    if salt is None:
        salt = secrets.token_bytes(32)
    
    chave = hashlib.pbkdf2_hmac(
        'sha256',
        senha.encode('utf-8'),
        salt,
        iteracoes
    )
    
    return chave, salt

# Criar chave
senha_mestra = "minha_senha_super_secreta"
chave, salt = derivar_chave(senha_mestra)

print(f"Chave: {chave.hex()}")
print(f"Salt: {salt.hex()}")

# Recriar chave com mesmo salt
chave2, _ = derivar_chave(senha_mestra, salt=salt)
assert chave == chave2  # Mesma chave!

Sistema de criptografia simples:
from cryptography.fernet import Fernet
import base64

class CriptografiaSimples:
    def __init__(self, senha_mestra):
        # Deriva chave de 32 bytes da senha
        chave, self.salt = derivar_chave(senha_mestra)
        
        # Fernet precisa de chave base64 de 32 bytes
        chave_fernet = base64.urlsafe_b64encode(chave)
        self.fernet = Fernet(chave_fernet)
    
    def criptografar(self, mensagem):
        """Criptografa mensagem."""
        if isinstance(mensagem, str):
            mensagem = mensagem.encode('utf-8')
        
        return self.fernet.encrypt(mensagem)
    
    def descriptografar(self, mensagem_cripto):
        """Descriptografa mensagem."""
        mensagem = self.fernet.decrypt(mensagem_cripto)
        return mensagem.decode('utf-8')

# Uso
cripto = CriptografiaSimples("senha_mestra_123")

# Criptografar
mensagem = "Dados confidenciais"
cripto_msg = cripto.criptografar(mensagem)
print(f"Criptografado: {cripto_msg}")

# Descriptografar
mensagem_original = cripto.descriptografar(cripto_msg)
print(f"Descriptografado: {mensagem_original}")

8.3 PROTEÇÕES ADICIONAIS
--------------------------------------------------------------------------------
Técnicas adicionais de segurança.

Adicionar pepper (secret global):
# Pepper é um secret global (não armazenado com senha)
PEPPER = secrets.token_bytes(32)

def hash_senha_com_pepper(senha, salt):
    """Hash de senha com salt E pepper."""
    # Combina senha com pepper antes de hashear
    senha_com_pepper = senha.encode() + PEPPER
    
    return hashlib.pbkdf2_hmac(
        'sha256',
        senha_com_pepper,
        salt,
        100000
    )

Rotação de tokens:
class TokenRotativo:
    def __init__(self):
        self.tokens_ativos = {}
        self.tokens_anteriores = {}
    
    def criar_token(self, user_id):
        """Cria novo token e mantém anterior válido."""
        novo_token = secrets.token_urlsafe(32)
        
        # Se já tem token ativo, move para anteriores
        if user_id in self.tokens_ativos:
            token_antigo = self.tokens_ativos[user_id]['token']
            self.tokens_anteriores[token_antigo] = {
                'user_id': user_id,
                'expira': time.time() + 300  # 5 min de overlap
            }
        
        # Salva novo token
        self.tokens_ativos[user_id] = {
            'token': novo_token,
            'criado': time.time()
        }
        
        return novo_token
    
    def validar_token(self, token):
        """Valida token (aceita atual ou anterior)."""
        # Verifica tokens ativos
        for user_id, dados in self.tokens_ativos.items():
            if secrets.compare_digest(token, dados['token']):
                return True, user_id
        
        # Verifica tokens anteriores
        if token in self.tokens_anteriores:
            dados = self.tokens_anteriores[token]
            if time.time() < dados['expira']:
                return True, dados['user_id']
            else:
                del self.tokens_anteriores[token]
        
        return False, None


================================================================================
RESUMO RÁPIDO
================================================================================

FUNÇÕES PRINCIPAIS:

# Números aleatórios
secrets.randbelow(n)              # Inteiro de 0 a n-1

# Tokens
secrets.token_hex(nbytes)         # String hexadecimal (0-9, a-f)
secrets.token_urlsafe(nbytes)     # String URL-safe (Base64)
secrets.token_bytes(nbytes)       # Bytes aleatórios

# Escolha aleatória
secrets.choice(sequence)          # Elemento aleatório

# Comparação segura
secrets.compare_digest(a, b)      # Compara strings com tempo constante

TAMANHOS RECOMENDADOS:
- Session IDs: 32 bytes (token_urlsafe)
- API Keys: 32 bytes (token_hex)
- Senhas: 12-16 caracteres (caracteres variados)
- Tokens de reset: 32 bytes (token_urlsafe)
- PINs: 6-8 dígitos
- Códigos 2FA: 6 dígitos

BOAS PRÁTICAS:
✅ Use secrets para dados sensíveis
✅ Use compare_digest para validar tokens/senhas
✅ Armazene apenas hashes de tokens, nunca texto plano
✅ Implemente expiração de tokens
✅ Use salt único para cada senha
✅ Implemente rate limiting
✅ Use tokens longos (32 bytes ou mais)
✅ Valide entrada do usuário

❌ Nunca use random para segurança
❌ Nunca armazene tokens em texto plano
❌ Nunca use tokens curtos (<16 bytes)
❌ Nunca compare tokens com == (use compare_digest)
❌ Nunca reutilize salts
❌ Nunca envie tokens por canais inseguros
❌ Nunca hardcode secrets no código

CONCEITOS-CHAVE:
- Aleatoriedade criptográfica: imprevisível
- Token: string aleatória para identificação
- Salt: valor aleatório único por senha
- Pepper: secret global não armazenado
- Hash: função unidirecional
- Timing attack: ataque baseado em tempo de resposta
- Rate limiting: limitar tentativas

CASOS DE USO:
1. Autenticação (login, sessões)
2. Tokens de reset de senha
3. Códigos de verificação (2FA)
4. API Keys
5. Cupons e vouchers
6. Códigos de convite
7. IDs únicos
8. Salts para hashing


================================================================================
DOCUMENTAÇÃO OFICIAL DO PYTHON - SECRETS
================================================================================

================================================================================
PRINCIPAL - BIBLIOTECA SECRETS
================================================================================
https://docs.python.org/3/library/secrets.html
Documentação oficial da biblioteca secrets

================================================================================
FUNÇÕES RELACIONADAS
================================================================================
https://docs.python.org/3/library/random.html
Biblioteca random (não use para segurança!)

https://docs.python.org/3/library/hashlib.html
Biblioteca hashlib (para hashing)

https://docs.python.org/3/library/hmac.html
Módulo HMAC (comparação segura)

================================================================================
SEGURANÇA E CRIPTOGRAFIA
================================================================================
https://docs.python.org/3/library/crypto.html
Serviços criptográficos

https://cryptography.io/
Biblioteca cryptography (Python)

https://owasp.org/www-project-web-security-testing-guide/
OWASP - Guia de segurança web

================================================================================
PADRÕES E RECOMENDAÇÕES
================================================================================
https://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-63b.pdf
NIST - Diretrizes de autenticação digital

https://cheatsheetseries.owasp.org/cheatsheets/Password_Storage_Cheat_Sheet.html
OWASP - Armazenamento de senhas

https://tools.ietf.org/html/rfc2898
RFC 2898 - PBKDF2 (derivação de chaves)

================================================================================
					AGRIPPA
================================================================================