================================================================================
                	TRATAMENTO DE EXCEÇÕES EM PYTHON
                           NÍVEL INICIANTE
================================================================================



================================================================================
1. INTRODUÇÃO A EXCEÇÕES
================================================================================

1.1 O QUE SÃO EXCEÇÕES?
--------------------------------------------------------------------------------
Exceções são erros que ocorrem durante a execução de um programa. Quando uma 
exceção acontece, o programa é interrompido, a menos que você trate o erro.

Exemplo de exceção não tratada:
numero = int("texto")  # ValueError: invalid literal for int()
# O programa para aqui!

Com tratamento:
try:
    numero = int("texto")
except ValueError:
    print("Erro: não é possível converter texto para número")
    numero = 0
# O programa continua executando!

1.2 POR QUE TRATAR EXCEÇÕES?
--------------------------------------------------------------------------------
Benefícios do tratamento de exceções:
- Evita que o programa quebre inesperadamente
- Permite recuperação elegante de erros
- Melhora a experiência do usuário
- Facilita a depuração e manutenção do código
- Permite logging de erros para análise posterior

1.3 EXCEÇÕES COMUNS EM PYTHON
--------------------------------------------------------------------------------
ValueError: Valor inadequado (ex: int("abc"))
TypeError: Tipo inadequado (ex: "texto" + 5)
ZeroDivisionError: Divisão por zero (ex: 10 / 0)
IndexError: Índice fora do intervalo (ex: lista[10] quando lista tem 3 itens)
KeyError: Chave não encontrada em dicionário (ex: dict["chave_inexistente"])
FileNotFoundError: Arquivo não encontrado
AttributeError: Atributo inexistente (ex: "texto".metodo_inexistente())
NameError: Variável não definida
ImportError: Falha ao importar módulo


================================================================================
2. ESTRUTURA TRY-EXCEPT
================================================================================

2.1 SINTAXE BÁSICA
--------------------------------------------------------------------------------
A estrutura try-except captura e trata exceções.

Estrutura:
try:
    # Código que pode gerar exceção
    codigo_arriscado()
except TipoDeExcecao:
    # Código executado se a exceção ocorrer
    tratar_erro()

Exemplo simples:
try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("Erro: não é possível dividir por zero!")
    resultado = None

2.2 CAPTURANDO MÚLTIPLAS EXCEÇÕES
--------------------------------------------------------------------------------
Você pode capturar diferentes tipos de exceções separadamente.

Exceções em blocos separados:
try:
    numero = int(input("Digite um número: "))
    resultado = 100 / numero
except ValueError:
    print("Erro: você não digitou um número válido!")
except ZeroDivisionError:
    print("Erro: não é possível dividir por zero!")

Múltiplas exceções em um único except:
try:
    arquivo = open("dados.txt")
    conteudo = arquivo.read()
except (FileNotFoundError, PermissionError):
    print("Erro ao acessar o arquivo!")

2.3 CAPTURANDO QUALQUER EXCEÇÃO
--------------------------------------------------------------------------------
Você pode capturar todas as exceções, mas use com cuidado!

Captura genérica (não recomendado como única opção):
try:
    operacao_arriscada()
except:
    print("Algum erro ocorreu!")

Melhor abordagem (captura Exception):
try:
    operacao_arriscada()
except Exception as e:
    print(f"Erro: {e}")

Ordem correta (específico antes de genérico):
try:
    numero = int("abc")
except ValueError:
    print("Erro de conversão!")
except Exception as e:
    print(f"Outro erro: {e}")

2.4 ACESSANDO INFORMAÇÕES DA EXCEÇÃO
--------------------------------------------------------------------------------
Use 'as' para armazenar a exceção em uma variável.

Exemplo:
try:
    resultado = 10 / 0
except ZeroDivisionError as erro:
    print(f"Tipo do erro: {type(erro).__name__}")
    print(f"Mensagem: {erro}")
    print(f"Argumentos: {erro.args}")

# Saída:
# Tipo do erro: ZeroDivisionError
# Mensagem: division by zero
# Argumentos: ('division by zero',)

Uso prático com conversão:
def converter_para_inteiro(texto):
    try:
        return int(texto)
    except ValueError as e:
        print(f"Não foi possível converter '{texto}': {e}")
        return None


================================================================================
3. CLÁUSULAS ELSE E FINALLY
================================================================================

3.1 CLÁUSULA ELSE
--------------------------------------------------------------------------------
O bloco 'else' é executado apenas se NENHUMA exceção ocorrer.

Sintaxe:
try:
    # Código que pode gerar exceção
    operacao()
except TipoExcecao:
    # Executado se houver exceção
    tratar_erro()
else:
    # Executado se NÃO houver exceção
    codigo_sucesso()

Exemplo prático:
def dividir(a, b):
    try:
        resultado = a / b
    except ZeroDivisionError:
        print("Erro: divisão por zero!")
    else:
        print(f"Resultado: {resultado}")
        return resultado

dividir(10, 2)   # Imprime: Resultado: 5.0
dividir(10, 0)   # Imprime: Erro: divisão por zero!

3.2 CLÁUSULA FINALLY
--------------------------------------------------------------------------------
O bloco 'finally' é SEMPRE executado, independente de exceções.

Sintaxe:
try:
    operacao()
except:
    tratar_erro()
finally:
    # Sempre executado (limpeza, fechamento de recursos)
    codigo_finalizacao()

Exemplo com arquivo:
def ler_arquivo(nome):
    arquivo = None
    try:
        arquivo = open(nome, 'r')
        conteudo = arquivo.read()
        return conteudo
    except FileNotFoundError:
        print(f"Arquivo {nome} não encontrado!")
        return None
    finally:
        if arquivo:
            arquivo.close()  # Sempre fecha o arquivo
            print("Arquivo fechado")

3.3 COMBINANDO TRY-EXCEPT-ELSE-FINALLY
--------------------------------------------------------------------------------
Você pode usar todas as cláusulas juntas.

Exemplo completo:
def processar_numero(texto):
    try:
        numero = int(texto)
        resultado = 100 / numero
    except ValueError:
        print("Erro: entrada inválida!")
        return None
    except ZeroDivisionError:
        print("Erro: divisão por zero!")
        return None
    else:
        print(f"Processamento bem-sucedido: {resultado}")
        return resultado
    finally:
        print("Processamento finalizado")

# Teste:
processar_numero("5")      # Sucesso
processar_numero("abc")    # ValueError
processar_numero("0")      # ZeroDivisionError

Fluxo de execução:
1. try: sempre executado primeiro
2. except: executado se houver exceção correspondente
3. else: executado se NÃO houver exceção
4. finally: sempre executado no final


================================================================================
4. LANÇANDO EXCEÇÕES
================================================================================

4.1 RAISE - LANÇANDO EXCEÇÕES
--------------------------------------------------------------------------------
Use 'raise' para lançar (gerar) uma exceção manualmente.

Sintaxe básica:
raise TipoExcecao("Mensagem de erro")

Exemplos:
raise ValueError("Valor inválido fornecido!")
raise TypeError("Tipo de dado incorreto!")
raise Exception("Erro genérico!")

4.2 VALIDAÇÃO COM RAISE
--------------------------------------------------------------------------------
Use raise para validar condições e parâmetros.

Exemplo - validação de idade:
def definir_idade(idade):
    if not isinstance(idade, int):
        raise TypeError("Idade deve ser um número inteiro!")
    if idade < 0:
        raise ValueError("Idade não pode ser negativa!")
    if idade > 150:
        raise ValueError("Idade inválida!")
    return idade

# Uso:
try:
    definir_idade(-5)
except ValueError as e:
    print(f"Erro: {e}")  # Idade não pode ser negativa!

Exemplo - divisão segura:
def dividir_seguro(a, b):
    if b == 0:
        raise ZeroDivisionError("Divisor não pode ser zero!")
    return a / b

4.3 RE-LANÇANDO EXCEÇÕES
--------------------------------------------------------------------------------
Você pode capturar, processar e re-lançar uma exceção.

Sintaxe:
try:
    operacao()
except Exception as e:
    # Processa o erro (log, notificação, etc)
    print(f"Erro capturado: {e}")
    # Re-lança a mesma exceção
    raise

Exemplo prático:
def processar_dados(dados):
    try:
        resultado = calcular(dados)
    except ValueError as e:
        print(f"LOG: Erro de valor - {e}")
        raise  # Re-lança para quem chamou a função tratar
    return resultado

4.4 ENCADEAMENTO DE EXCEÇÕES
--------------------------------------------------------------------------------
Você pode lançar uma nova exceção mantendo a original.

Usando 'from':
try:
    numero = int("abc")
except ValueError as e:
    raise RuntimeError("Falha no processamento") from e

Isso cria uma cadeia de exceções que ajuda na depuração.


================================================================================
5. EXCEÇÕES PERSONALIZADAS
================================================================================

5.1 CRIANDO EXCEÇÕES PRÓPRIAS
--------------------------------------------------------------------------------
Você pode criar suas próprias classes de exceção.

Sintaxe básica:
class MinhaExcecao(Exception):
    pass

Uso:
raise MinhaExcecao("Algo deu errado!")

5.2 EXCEÇÕES COM ATRIBUTOS
--------------------------------------------------------------------------------
Adicione atributos para armazenar informações adicionais.

Exemplo - erro de saldo:
class SaldoInsuficienteError(Exception):
    def __init__(self, saldo, valor):
        self.saldo = saldo
        self.valor = valor
        mensagem = f"Saldo insuficiente: R${saldo:.2f} < R${valor:.2f}"
        super().__init__(mensagem)

# Uso:
class ContaBancaria:
    def __init__(self, saldo):
        self.saldo = saldo
    
    def sacar(self, valor):
        if valor > self.saldo:
            raise SaldoInsuficienteError(self.saldo, valor)
        self.saldo -= valor

# Teste:
conta = ContaBancaria(100)
try:
    conta.sacar(150)
except SaldoInsuficienteError as e:
    print(f"Erro: {e}")
    print(f"Saldo disponível: R${e.saldo:.2f}")

5.3 HIERARQUIA DE EXCEÇÕES
--------------------------------------------------------------------------------
Organize exceções relacionadas em uma hierarquia.

Exemplo - sistema de validação:
class ErroValidacao(Exception):
    """Exceção base para erros de validação"""
    pass

class ErroIdade(ErroValidacao):
    """Idade inválida"""
    pass

class ErroEmail(ErroValidacao):
    """Email inválido"""
    pass

class ErroSenha(ErroValidacao):
    """Senha inválida"""
    pass

# Uso:
def validar_usuario(idade, email, senha):
    if idade < 18:
        raise ErroIdade("Usuário deve ser maior de 18 anos")
    if "@" not in email:
        raise ErroEmail("Email inválido")
    if len(senha) < 8:
        raise ErroSenha("Senha deve ter no mínimo 8 caracteres")

# Captura específica:
try:
    validar_usuario(15, "teste@email.com", "123")
except ErroIdade as e:
    print(f"Problema com idade: {e}")
except ErroValidacao as e:
    print(f"Erro de validação: {e}")


================================================================================
6. BOAS PRÁTICAS
================================================================================

6.1 SEJA ESPECÍFICO
--------------------------------------------------------------------------------
Prefira capturar exceções específicas em vez de genéricas.

❌ Evite:
try:
    operacao()
except:
    print("Erro!")

✅ Prefira:
try:
    operacao()
except FileNotFoundError:
    print("Arquivo não encontrado!")
except PermissionError:
    print("Sem permissão para acessar!")

6.2 NÃO SILENCIE ERROS
--------------------------------------------------------------------------------
Não capture exceções sem fazer nada.

❌ Evite:
try:
    operacao_critica()
except:
    pass  # Silencia o erro - muito perigoso!

✅ Prefira:
try:
    operacao_critica()
except Exception as e:
    print(f"Erro na operação: {e}")
    # Ou use logging
    # logging.error(f"Erro: {e}")

6.3 USE FINALLY PARA LIMPEZA
--------------------------------------------------------------------------------
Sempre limpe recursos (arquivos, conexões) no finally.

✅ Bom exemplo:
arquivo = None
try:
    arquivo = open("dados.txt", "r")
    processar(arquivo)
except FileNotFoundError:
    print("Arquivo não encontrado")
finally:
    if arquivo:
        arquivo.close()

Ainda melhor - use gerenciadores de contexto:
try:
    with open("dados.txt", "r") as arquivo:
        processar(arquivo)
except FileNotFoundError:
    print("Arquivo não encontrado")
# Arquivo é fechado automaticamente!

6.4 MENSAGENS CLARAS
--------------------------------------------------------------------------------
Forneça mensagens de erro descritivas e úteis.

❌ Evite:
raise ValueError("Erro!")

✅ Prefira:
raise ValueError(f"Idade deve estar entre 0 e 150, recebido: {idade}")

6.5 DOCUMENTE EXCEÇÕES
--------------------------------------------------------------------------------
Documente quais exceções suas funções podem lançar.

✅ Exemplo:
def dividir(a, b):
    """
    Divide dois números.
    
    Args:
        a (float): Dividendo
        b (float): Divisor
    
    Returns:
        float: Resultado da divisão
    
    Raises:
        ZeroDivisionError: Se b for zero
        TypeError: Se a ou b não forem números
    """
    if not isinstance(a, (int, float)) or not isinstance(b, (int, float)):
        raise TypeError("Ambos os argumentos devem ser números")
    if b == 0:
        raise ZeroDivisionError("Divisor não pode ser zero")
    return a / b

6.6 EVITE TRY-EXCEPT MUITO AMPLOS
--------------------------------------------------------------------------------
Blocos try devem conter apenas código que pode falhar.

❌ Evite:
try:
    arquivo = abrir_arquivo()
    dados = processar_dados()
    resultado = calcular(dados)
    salvar_resultado(resultado)
    enviar_email()
except Exception:
    print("Algo falhou!")

✅ Prefira:
try:
    arquivo = abrir_arquivo()
except FileNotFoundError:
    print("Arquivo não encontrado")
    return

dados = processar_dados()

try:
    resultado = calcular(dados)
except ValueError:
    print("Erro no cálculo")
    return

salvar_resultado(resultado)


================================================================================
7. PADRÕES COMUNS
================================================================================

7.1 EAFP VS LBYL
--------------------------------------------------------------------------------
Python prefere EAFP (Easier to Ask for Forgiveness than Permission).

LBYL (Look Before You Leap) - verificar antes:
if chave in dicionario:
    valor = dicionario[chave]
else:
    valor = None

EAFP (Python idiomático) - tentar e capturar:
try:
    valor = dicionario[chave]
except KeyError:
    valor = None

Ou simplesmente:
valor = dicionario.get(chave)  # Retorna None se não existir

7.2 CONVERSÃO SEGURA
--------------------------------------------------------------------------------
Padrão para converter valores com fallback.

def converter_int_seguro(texto, padrao=0):
    try:
        return int(texto)
    except (ValueError, TypeError):
        return padrao

# Uso:
numero = converter_int_seguro("123")      # 123
numero = converter_int_seguro("abc")      # 0
numero = converter_int_seguro("abc", -1)  # -1

7.3 TENTATIVAS MÚLTIPLAS (RETRY)
--------------------------------------------------------------------------------
Padrão para tentar novamente em caso de falha.

import time

def operacao_com_retry(max_tentativas=3):
    for tentativa in range(max_tentativas):
        try:
            # Operação que pode falhar
            resultado = operacao_instavel()
            return resultado
        except Exception as e:
            print(f"Tentativa {tentativa + 1} falhou: {e}")
            if tentativa < max_tentativas - 1:
                time.sleep(1)  # Aguarda antes de tentar novamente
            else:
                raise  # Re-lança após última tentativa

7.4 VALIDAÇÃO DE ENTRADA
--------------------------------------------------------------------------------
Padrão para validar entrada do usuário.

def obter_numero_valido(mensagem):
    while True:
        try:
            entrada = input(mensagem)
            numero = float(entrada)
            if numero < 0:
                print("Por favor, digite um número positivo.")
                continue
            return numero
        except ValueError:
            print("Entrada inválida. Digite um número.")
        except KeyboardInterrupt:
            print("\nOperação cancelada.")
            return None

7.5 LOGGING DE ERROS
--------------------------------------------------------------------------------
Padrão para registrar erros em log.

import logging

logging.basicConfig(level=logging.ERROR)

def processar_arquivo(nome):
    try:
        with open(nome, 'r') as arquivo:
            return arquivo.read()
    except FileNotFoundError as e:
        logging.error(f"Arquivo não encontrado: {nome}")
        raise
    except Exception as e:
        logging.error(f"Erro ao processar {nome}: {e}")
        raise


================================================================================
8. CONTEXTOS DE USO AVANÇADOS
================================================================================

8.1 ASSERTIONS
--------------------------------------------------------------------------------
Use 'assert' para verificações que nunca devem falhar.

Sintaxe:
assert condicao, "Mensagem se falhar"

Exemplo:
def calcular_media(notas):
    assert len(notas) > 0, "Lista de notas não pode estar vazia"
    assert all(0 <= nota <= 10 for nota in notas), "Notas devem estar entre 0 e 10"
    return sum(notas) / len(notas)

Nota: Assertions podem ser desabilitadas com -O na execução do Python,
então não as use para validação de entrada de usuário!

8.2 CONTEXT MANAGERS (WITH)
--------------------------------------------------------------------------------
Use 'with' para gerenciar recursos automaticamente.

Arquivos:
with open("arquivo.txt", "r") as arquivo:
    conteudo = arquivo.read()
# Arquivo fechado automaticamente, mesmo se houver exceção!

Criando seu próprio context manager:
class GerenciadorRecurso:
    def __enter__(self):
        print("Abrindo recurso")
        return self
    
    def __exit__(self, tipo_exc, valor_exc, traceback):
        print("Fechando recurso")
        if tipo_exc:
            print(f"Exceção capturada: {valor_exc}")
        return False  # Não suprime exceções

# Uso:
with GerenciadorRecurso() as recurso:
    print("Usando recurso")


================================================================================
RESUMO RÁPIDO
================================================================================

ESTRUTURA BÁSICA:
try:
    # Código que pode falhar
except TipoExcecao as e:
    # Trata o erro específico
else:
    # Executado se NÃO houver exceção
finally:
    # Sempre executado (limpeza)

CONCEITOS-CHAVE:
- Exceções são erros durante execução
- try-except captura e trata exceções
- else executa apenas se não houver exceção
- finally sempre executa (use para limpeza)
- raise lança exceções manualmente
- Crie exceções personalizadas herdando de Exception

EXCEÇÕES COMUNS:
- ValueError: valor inadequado
- TypeError: tipo inadequado
- ZeroDivisionError: divisão por zero
- IndexError: índice fora do intervalo
- KeyError: chave não encontrada
- FileNotFoundError: arquivo não encontrado

BOAS PRÁTICAS:
✅ Seja específico nas exceções capturadas
✅ Não silencie erros sem bom motivo
✅ Use finally para limpeza de recursos
✅ Forneça mensagens de erro claras
✅ Documente exceções que funções podem lançar
✅ Prefira EAFP (try-except) em vez de LBYL (if-else)
✅ Use 'with' para gerenciar recursos (arquivos, conexões)

❌ Evite capturar Exception genérica sem necessidade
❌ Evite blocos try muito amplos
❌ Não use except sem especificar a exceção
❌ Não use exceções para controle de fluxo normal

DICAS:
- Use logging para registrar erros em produção
- Teste seus tratamentos de exceção
- Considere criar hierarquias de exceções personalizadas
- Em aplicações sérias, sempre trate exceções adequadamente


================================================================================
DOCUMENTAÇÃO OFICIAL DO PYTHON - EXCEÇÕES
================================================================================

================================================================================
PRINCIPAL - ERROS E EXCEÇÕES
================================================================================
https://docs.python.org/3/tutorial/errors.html
Tutorial oficial sobre tratamento de erros e exceções

================================================================================
DOCUMENTAÇÃO DETALHADA
================================================================================
https://docs.python.org/3/library/exceptions.html
Hierarquia completa de exceções built-in do Python

https://docs.python.org/3/reference/compound_stmts.html#the-try-statement
Referência completa da declaração try

https://docs.python.org/3/reference/simple_stmts.html#the-raise-statement
Referência completa da declaração raise

https://docs.python.org/3/reference/simple_stmts.html#the-assert-statement
Referência sobre assertions

================================================================================
CONTEXTOS E RECURSOS
================================================================================
https://docs.python.org/3/reference/compound_stmts.html#the-with-statement
Declaração with e context managers

https://docs.python.org/3/library/contextlib.html
Biblioteca contextlib para criar context managers

================================================================================
LOGGING
================================================================================
https://docs.python.org/3/library/logging.html
Módulo logging para registro de erros e eventos

https://docs.python.org/3/howto/logging.html
Tutorial de logging

================================================================================
			AGRIPPA
================================================================================